#!/bin/bash -u
#
# Pre-receive hook to limit pushed file size and run filename only validation
#
# Derived from https://github.com/mgit-at/git-max-filesize
# Author: Christoph Hack <chack@mgit.at>
# Copyright (c) 2017 mgIT GmbH. All rights reserved.
# Distributed under the Apache License. See http://www.apache.org/licenses/LICENSE-2.0 for details.
#
set -o pipefail

readonly MAXSIZE="10485760" # 10MB
readonly NULLSHA="0000000000000000000000000000000000000000"
readonly EXIT_SUCCESS="0"
readonly EXIT_FAILURE="1"

readonly requiredGitAttributes=(
  "* annex.largefiles=largerthan=1mb"
  "*.bval annex.largefiles=nothing"
  "*.bvec annex.largefiles=nothing"
  "*.json annex.largefiles=nothing"
  "*.tsv annex.largefiles=nothing"
  ".bidsignore annex.largefiles=nothing"
  "CHANGES annex.largefiles=nothing"
  "README annex.largefiles=nothing"
)

function validateGitAttributes() {
  local missingLines=()

  # Find .gitattributes file
  local gitAttributes="../.gitattributes"
  if [ -f $gitAttributes ]; then 
    # Check for required lines in .gitattributes file
    for line in "$requiredGitAttributes"; do
      if ! grep -q "$line" "$gitAttributes"; then
        missingLines+="$line"
      fi
    done
  fi

  if [ ${#missingLines[@]} -gt 0 ]; then
    echo ""
    echo "---------------------------------------------------------------------------------------"
    echo "Your push was rejected because your .gitattributes file is missing the following lines:"
    echo "---------------------------------------------------------------------------------------"
    for missingLine in "$missingLines"; do
      echo "  $missingLine"
    done
    exit 1
  fi
}

# Reject the push if any files start with a . character
function filterDotFiles() {
  local newFiles=$(git diff --stat --name-only --diff-filter=ACMRT ${oldref}..${newref})
  for filename in $newFiles; do
    if [[ "$filename" = ".bidsignore" ]] || [[ "$filename" =~ ".gitattributes" ]] || [[ "$filename" = ".gitmodules" ]] || [[ "$filename" =~ ^.gitignore|\/\.gitignore ]] || [[ "$filename" =~ ^\.datalad ]]; then
      continue
    fi
    if [[ "$filename" =~ ^\..*|\/\..* ]]; then
      echo ""
      echo "-------------------------------------------------------------------------"
      echo "Filenames beginning with . except for .bidsignore or DataLad repo settings are not allowed"
      echo "-------------------------------------------------------------------------"
      exit 1
    fi
  done
}

# main entry point
function main() {
  local status="$EXIT_SUCCESS"

  # read lines from stdin (format: "<oldref> <newref> <refname>\n")
  local oldref
  local newref
  local refname
  while read oldref newref refname; do
    # skip branch deletions
    if [[ "$newref" == "$NULLSHA" ]]; then
      continue
    fi

    case $refname in
      refs/heads/*)
        branch=$(expr "$refname" : "refs/heads/\(.*\)")
        if ! [[ "$branch" == "master" || "$branch" == "git-annex" || "$branch" == "main" || "$branch" =~ "^synced\/.*$" ]]; then
          echo ""
          echo "-------------------------------------------------------------------------"
          echo "Only 'master', 'main', or 'git-annex' branches are accepted."
          echo "-------------------------------------------------------------------------"
          exit $EXIT_FAILURE
        fi
        ;;
      refs/tags/*)
        tag=$(expr "$refname" : "refs/tags/\(.*\)")
        if ! [[ "$tag" =~ "^[0-9]+\.[0-9]+\.[0-9]+$" ]]; then
          echo ""
          echo "-------------------------------------------------------------------------"
          echo "Only version numbered tags are accepted, e.g. '1.2.3'"
          echo "-------------------------------------------------------------------------"
          exit $EXIT_FAILURE
        fi
        ;;
    esac

    # find large objects
    # check all objects from $oldref (possible $NULLSHA) to $newref, but
    # skip all objects that have already been accepted (i.e. are referenced by
    # another branch or tag).
    local target
    if [[ "$oldref" == "$NULLSHA" ]]; then
      target="$newref"
    else
      target="${oldref}..${newref}"
    fi
    local large_files
    large_files="$(git rev-list --objects "$target" --not --branches=\* --tags=\* | \
      git cat-file $'--batch-check=%(objectname)\t%(objecttype)\t%(objectsize)\t%(rest)' | \
      awk -F '\t' -v maxbytes="$MAXSIZE" '$3 > maxbytes' | cut -f 4-)"
    if [[ "$?" != 0 ]]; then
      echo "failed to check for large files in ref ${refname}"
      continue
    fi

    filterDotFiles

    # Check if .bidsignore is in the new tree
    local bidsignore=$(git show "${newref}:.bidsignore")
    if [[ "$?" != 0 ]]; then
      bidsignore=""
    fi

    # Run validation (with .bidsignore if we found it above)
    { echo "${bidsignore}" && echo "0001" && git ls-tree --name-only -r "${newref}"; } | \
      /node_modules/.bin/bids-validator --filenames -
    if [[ "$?" != 0 ]]; then
      echo ""
      echo "-------------------------------------------------------------------------"
      echo "Your push was rejected because it failed validation."
      echo "Please test with bids-validator locally to resolve any errors before pushing."
      echo "-------------------------------------------------------------------------"
      exit $EXIT_FAILURE
    fi

    IFS=$'\n'
    for file in $large_files; do
      if [[ "$status" == 0 ]]; then
        echo ""
        echo "-------------------------------------------------------------------------"
        echo "Your push was rejected because it contains files larger than 10MB."
        echo "Please use git-annex to store larger files."
        echo "-------------------------------------------------------------------------"
        echo ""
        echo "Offending files:"
        status="$EXIT_FAILURE"
      fi
      echo " - ${file} (ref: ${refname})"
    done
    unset IFS
  done

  validateGitAttributes

  exit "$status"
}

main
